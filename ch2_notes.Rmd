---
title: "chp2_notes"
author: "William Hall"
date: "June 8, 2016"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
```

## Subseting

## Data types

###Atomic Vectors

* There are six ways to subset an atomic vector

```{r}
x <- 10:20
#positive numbers
x[1:3]
#negative numbers
x[-c(2,1)]
#logicals - uses recyclying
x[c(T,T,F)]
#nothing
x[]
#zereo
x[0]
#names
(y <- setNames(x, letters[1:10]))
y[c("a", "b", "c")]
```


###Lists

* subsetting with [[]] returns a vector
* subsetting with [] or $ returns a list

###Arrays and matricies

* 2d arrays are subsetted liked data frames
* you provide two vectors seperated by a comma to select the rows and columns you want.
* you can also subset a matrix with another matrix.

### Data frames
 
* data frames are kind of a hybrid between a list and matrix and thus you can subset usin techniques from both.

```{r}
df <- data.frame(x = 1:3, y = 3:1, z = letters[1:3])

#subsetting like a list returns a data frame.
df["x"] %>% class
#subsetting like a matrix returns a vector
df[, "x"] %>% class

```

###S3 and S4 objects 

* all S3 objects can be subsetted using the rules described above
* S4 objects have two extra subset operations:
  * @ lets you subset like $
  * slot() is like [[]]

##Excercises

1. Fix each of the following common data frame subsetting errors:

```{r}
#mtcars[mtcars$cyl = 4, ]
mtcars[mtcars$cyl == 4, ]

#mtcars[-1:4, ]
mtcars[-1:-4, ]

#mtcars[mtcars$cyl <= 5]
mtcars[mtcars$cyl <= 5,]

#mtcars[mtcars$cyl == 4 | 6, ]
mtcars[mtcars$cyl == 4 | mtcars$cyl == 6, ]
```
    
2. Why does x <- 1:5; x[NA] yield five missing values? (Hint: why is it different from x[NA_real_]?)

```{r}
x <- 1:5; x[NA]
x[NA_real_]
```

* The first line of code returns five missing values because a logical is being used to subset a vector; the logical gets recycled 5 times, but the test is neither true or false and thus returns NA.  The second command is different because now you are indexing a vector with a number but the number is NA is so the index doesn't return anything. 

3. What does upper.tri() return? How does subsetting a matrix with it work? Do we need any additional subsetting rules to describe its behaviour?

```{r}
x <- outer(1:5, 1:5, FUN = "*")
x[upper.tri(x)]
#?upper.tri()

```

* upper.tri() isolates the upper elements (above the diagonal) of a matrix; i.e. it creates a matrix where the upper elements are true. This would be good for selecting the upper (or lower) elements of a matrix.

4. Why does mtcars[1:20] return an error? How does it differ from the similar mtcars[1:20, ]?

```{r}
try(mtcars[1:20])
```

It returns an error because R thinks you are trying to subset the columns of a data frame and there aren't 20 columns in the mtcars df. mtcars[1:20,] returns the first two rows and all the columns. 

5. Implement your own function that extracts the diagonal entries from a matrix (it should behave like diag(x) where x is a matrix).

* Remember that you can subset a matrix with another matrix.

```{r}
x <- outer(1:5, 1:5, FUN = "*")

diag_ <- function(mat){
  mat[cbind(seq_len(ncol(mat)), seq_len(ncol(mat)))]
}

# does the same thing but uses dplyr

x %>% 
  ncol %>% 
  seq_len %>% 
  cbind(.,.) %>% 
  x[.]

diag_(x)


```


6. What does df[is.na(df)] <- 0 do? How does it work?

```{r}
df[is.na(df)] <- 0
```

* sets NA values in a df to zero
